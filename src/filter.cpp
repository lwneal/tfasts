#include "Mask.h"
#include "Image.h"
#include "Utility.h"
#include "Features.h"
#include "pRandomForest.h"

#include "dlib/cmd_line_parser.h"
#include "dlib/image_io.h"

#include <vector>
#include <string>
#include <iostream>

using namespace std;

struct Options {
	int fft_width = 512;
	int fft_step = 256;
	int hi_pass_hz = 300;
	double theta = 1;
	string input_path;
	string model_path;
	string output_path;
	string label_path;
	string out_label_path;
	bool good() {
		return (model_path.size() || label_path.size())
			&& input_path.size() && output_path.size()
			&& fft_width > 0 && fft_step > 0
			&& hi_pass_hz >= 0;
	}
};

Options learn_parse_args(int argc, char *argv[]) {
	dlib::cmd_line_parser<char>::check_1a_c parser;
	parser.add_option("h", "Display this help message");
	parser.add_option("i", "An input .wav audio file", 1);
	parser.add_option("o", "Output noise-reduced .wav audio file",1);
	parser.add_option("w", "Integer FFT width (2x the output spectrogram image height). Default 512", 1);
	parser.add_option("s", "FFT Step (smaller step sizes result in a wider image). Default 256", 1);
	parser.add_option("p", "High-Pass cutoff in Hz. Default 300", 1);
	parser.add_option("m", "Model file, generated by 'learn'", 1);
	parser.add_option("a", "If using -m, output filename for BMP of the label (this label can then be re-used with -l)", 1);
	parser.add_option("l", "Label file, can be used as a replacement for -m. Must be a monochrome BMP the same shape as the spectrogram. White areas will be included in the output, and black deleted.", 1);
	parser.add_option("t", "Theta: Lower means less noise reduction, higher eliminates more sound. Default 1", 1);
	parser.parse(argc, argv);

	Options opts;
	if (parser.number_of_arguments() > 0)
		opts.input_path = parser[0];
	if (parser.number_of_arguments() > 1)
		opts.output_path = parser[1];

	if (parser.option("i") && parser.option("i").count() > 0)
		opts.input_path = parser.option("i").argument();
	if (parser.option("o") && parser.option("o").count() > 0)
		opts.output_path = parser.option("o").argument();
	if (parser.option("m") && parser.option("m").count() > 0)
		opts.model_path = parser.option("m").argument();
	if (parser.option("l") && parser.option("l").count() > 0)
		opts.label_path = parser.option("l").argument();
	if (parser.option("a") && parser.option("a").count() > 0)
		opts.out_label_path = parser.option("a").argument();
	if (parser.option("w") && parser.option("w").count() > 0)
		opts.fft_width = dlib::sa = parser.option("w").argument();
	if (parser.option("s") && parser.option("s").count() > 0)
		opts.fft_step = dlib::sa = parser.option("s").argument();
	if (parser.option("p") && parser.option("p").count() > 0)
		opts.hi_pass_hz = dlib::sa = parser.option("p").argument();
	if (parser.option("t") && parser.option("t").count() > 0)
		opts.theta = dlib::sa = parser.option("t").argument();
		
	if (!opts.good()) {
		cout << "\tfilter -m model.rf noisy.wav filtered.wav" << endl;
		parser.print_options();
		exit(1);
	}
	return opts;
}

int main(int argc, char *argv[]) {
	Options opt = learn_parse_args(argc, argv);

	cout << "Generating spectrogram" << endl;

	Mask spec(opt.input_path, opt.fft_width, opt.fft_step);

	cout << "Processing spectrogram" << endl;

	spec = preprocess_spec_icassp(spec, opt.hi_pass_hz);

	if (opt.label_path.size()) {

		Mask label(opt.label_path);

		cout << "Loaded label mask " << label.toString();

		label.attenuate_wav(opt.input_path, opt.output_path);

		cout << "Finished applying label" << endl;

	} else {

		cout << "Loading Random Forest from " << opt.model_path << endl;
		pRandomForest rf;
		rf.load(opt.model_path);
		cout << "Applying RF scoring to spectrogram: " << spec.toString() << endl;

		Mask scores(spec.width(), spec.height(), [&](int x, int y) {
			vector<float> feature(extract_feature_perpixel_icassp(spec, x, y));
			float score = rf.estimateClassProbabilities(feature)[0];
			return score;
		});
	
		scores = scores.gaussian_blur(4).norm_to_mean(1.0).raise_to(opt.theta);

		if (opt.out_label_path.size())
			Image(scores).save(opt.out_label_path);

		cout << "Attenuate wav" << endl;
		
		scores.attenuate_wav(opt.input_path, opt.output_path);
		cout << "Finished attenuate wav" << endl;
	}
	
	return 0;
}
