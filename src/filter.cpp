#include "Mask.h"
#include "Image.h"
#include "Utility.h"
#include "Features.h"
#include "pRandomForest.h"

#include "dlib/cmd_line_parser.h"
#include "dlib/image_io.h"

#include <vector>
#include <string>
#include <iostream>

using namespace std;

struct Options {
	int fft_width = 512;
	int fft_step = 256;
	int hi_pass_hz = 300;
	double theta = 0.15;
	string input_path;
	string model_path;
	string output_path;
	bool good() {
		return model_path.size() && input_path.size() && output_path.size()
			&& fft_width > 0 && fft_step > 0
			&& hi_pass_hz >= 0;
	}
};

Options learn_parse_args(int argc, char *argv[]) {
	dlib::cmd_line_parser<char>::check_1a_c parser;
	parser.add_option("h", "Display this help message");
	parser.add_option("i", "An input .wav audio file", 1);
	parser.add_option("o", "Filename for output .rf model file",1);
	parser.add_option("w", "Integer FFT width (2x the output spectrogram image height). Default 512", 1);
	parser.add_option("s", "FFT Step (smaller step sizes result in a wider image). Default 256", 1);
	parser.add_option("p", "High-Pass cutoff in Hz. Default 300", 1);
	parser.add_option("m", "Model file, generated by 'learn'", 1);
	parser.add_option("t", "Theta: Lower means less noise reduction, higher eliminates more sound. Default 0.15", 1);
	parser.parse(argc, argv);

	Options opts;
	if (parser.number_of_arguments() > 0)
		opts.input_path = parser[0];
	if (parser.number_of_arguments() > 1)
		opts.output_path = parser[1];

	if (parser.option("i") && parser.option("i").count() > 0)
		opts.input_path = parser.option("i").argument();
	if (parser.option("o") && parser.option("o").count() > 0)
		opts.output_path = parser.option("o").argument();
	if (parser.option("m") && parser.option("m").count() > 0)
		opts.model_path = parser.option("m").argument();
	if (parser.option("w") && parser.option("w").count() > 0)
		opts.fft_width = dlib::sa = parser.option("w").argument();
	if (parser.option("s") && parser.option("s").count() > 0)
		opts.fft_step = dlib::sa = parser.option("s").argument();
	if (parser.option("p") && parser.option("p").count() > 0)
		opts.hi_pass_hz = dlib::sa = parser.option("p").argument();
	if (parser.option("t") && parser.option("t").count() > 0)
		opts.theta = dlib::sa = parser.option("t").argument();
		
	if (!opts.good()) {
		cout << "\tfilter -m model.rf noisy.wav filtered.wav" << endl;
		parser.print_options();
		exit(1);
	}
	return opts;
}

int main(int argc, char *argv[]) {
	Options opt = learn_parse_args(argc, argv);

	pRandomForest rf;
	rf.load(opt.model_path);

	Mask spec(opt.input_path, opt.fft_width, opt.fft_step);

	spec = preprocess_spec_icassp(spec, opt.hi_pass_hz);

	Mask scores(spec.width(), spec.height(), [&](int x, int y) {
		vector<float> feature(extract_feature_perpixel_icassp(spec, x, y));
		float score = rf.estimateClassProbabilities(feature)[0];
		return score;
	});

	// blur scores?
	
	scores.attenuate_wav(opt.input_path, opt.output_path);
	
	return 0;
}
